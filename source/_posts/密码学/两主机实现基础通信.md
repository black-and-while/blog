---
title: 两主机实现基础通信
date: '2022/1/23 23:15:01'
categories:
  - - 密码学
description: 关于两主机基础通信的实现及其脚本
abbrlink: 1f960b6b
tags:
---

# 两主机实现基础通信

## informationSenter.py 文件（发送方）

（1）建立连接
（2）发送方把 RSA 公钥传递给接收方
（3）接受对方的 RSA 公钥， 使用自身的 DES 密钥和 IV 向量对信息进行加密
（4）对 DES 密钥和 IV 向量使用自己的私钥签名，用对方的公钥加密，传递给对方
（5）传递 DES 加密后的消息给对方

```python
#coding:utf-8
from socket import *
from CommunicationRSA import *
from CommunicationDES import *
from time import sleep

# 建立连接
tcp_socket = socket(AF_INET, SOCK_STREAM)
serve_ip = "192.168.65.128"  # 服务器端（主机B）的IP
serve_port = 12000  # 端口
tcp_socket.connect((serve_ip, serve_port))  # 连接服务器，建立连接,参数是元组形式

print("成功建立通信")
# 生成RSA的公钥和私钥
A_n = ""
A_e = ""
A_d = ""
(A_n, A_e, A_d) = produce_RSA()
print("成功生成RSA公私钥")
# 发送RSA的公钥给对方
tcp_socket.sendall(A_n.encode())
sleep(0.5)
tcp_socket.sendall(A_e.encode())

# 接受对方的RSA的公钥
B_n = tcp_socket.recv(1024).decode()
B_e = tcp_socket.recv(1024).decode()
print("成功接受对方RSA公钥")
# 定义自己DES的密钥和向量
A_key = "12343248"
A_IV = "12123678"

# 对DES的key和IV，使用对方的公钥进行加密，然后使用自己的RSA密钥进行签名
encrypto_A_key_1 = RSA_encode(B_n, B_e, str_to_16(A_key))
encrypto_A_key_2 = RSA_encode(A_n, A_d, encrypto_A_key_1)
encrypto_A_IV_1 = RSA_encode(B_n, B_e, str_to_16(A_IV))
encrypto_A_IV_2 = RSA_encode(A_n, A_d, encrypto_A_IV_1)

# 发送加密后key和IV给对方
tcp_socket.sendall(encrypto_A_key_2.encode())
sleep(1)
tcp_socket.sendall(encrypto_A_IV_2.encode())
sleep(1)
print("成功发送key和IV")
# 读入文件内容并进行DES加密
file = open("sent.txt", "r", encoding='utf-8')
cryptotext = ""
plaintext = file.read()
cryptotext = DES_encrypto(plaintext, A_key, A_IV)

# 发送加密的内容给B
tcp_socket.sendall(cryptotext.encode())
sleep(1)
tcp_socket.sendall("EOF".encode())
print("成功发送加密内容")
# 接收1024byte数据
from_server_msg = tcp_socket.recv(1024)
print(from_server_msg.decode())
# 关闭连接
tcp_socket.close()
```

## informationReceiver.py 文件（接收方）

（1）建立连接
（2）接收方接受发送方的 RSA 公钥
（3）把自己的 RSA 公钥发送给对方
（4）收到对方信息后
（5）使用对方的公钥进行验证，再使用自己的私钥进行解密，最终得到明文

```python
# coding:utf-8
from socket import *
from CommunicationRSA import *
from CommunicationDES import *
from time import sleep

# 建立连接
tcp_server = socket(AF_INET, SOCK_STREAM)
tcp_server.bind(('192.168.159.128', 12000))
tcp_server.listen(1)
client_socket, clientAddr = tcp_server.accept()

# 接收对方发送过来的数据
print("成功建立通信")
# 生成RSA的公钥和私钥
B_n = ""
B_e = ""
B_d = ""
(B_n, B_e, B_d) = produce_RSA()
print("成功生成RSA公私钥")
# 接受对方的RSA的公钥
A_n = client_socket.recv(1024).decode()
A_e = client_socket.recv(1024).decode()
print("成功接受对方RSA公钥")
# 发送RSA的公钥给对方
client_socket.sendall(B_n.encode())
sleep(1)
client_socket.sendall(B_e.encode())

# 接受对方的DES的key和IV
encrypto_A_key_1 = client_socket.recv(1024).decode()
encrypto_A_IV_1 = client_socket.recv(1024).decode()
print("成功接受key和IV")
# 解密和验证DES的key和IV，先使用对方的公钥进行验证，再使用自己的私钥进行解密
decrypto_A_key_1 = RSA_decode(encrypto_A_key_1, A_e, A_n)
A_key = RSA_decode(decrypto_A_key_1, B_d, B_n)
A_key = str16_to_str(A_key)
decrypto_A_IV_1 = RSA_decode(encrypto_A_IV_1, A_e, A_n)
A_IV = RSA_decode(decrypto_A_IV_1, B_d, B_n)
A_IV = str16_to_str(A_IV)

plaintext = ""
cryptotext = ""
# 接受加密的内容，进行解密
while True:
    temp_cryptotext = client_socket.recv(1024).decode()
    if temp_cryptotext[-3:] == "EOF":
        cryptotext += temp_cryptotext[:-3]
        break
    cryptotext += temp_cryptotext

plaintext = DES_decrypto(cryptotext, A_key, A_IV)

print("传输的信息为：", plaintext)

# 发送数据给客户端
send_data = client_socket.sendall("kali收到".encode())
# 关闭套接字
client_socket.close()
```

## CommunicationDES.py 文件

修改后的DES加密，用于方便实现通信

```python

#coding:utf-8
import base64

PC1 = [0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
       63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
left_move_arr = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
PC2 = [0, 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
       55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
IP = [0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40,
      32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55,
      47, 39, 31, 23, 15, 7]
IP_ = [0, 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13,
       53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33,
       1, 41, 9, 49, 17, 57, 25]
E = [0, 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20,
     21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]
S = [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
      [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
      [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
      [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],
     [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
      [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
      [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
      [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],
     [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
      [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
      [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
      [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],
     [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
      [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 19],
      [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
      [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],
     [[2, 12, 4, 1, 7, 10, 11, 6, 5, 8, 3, 15, 13, 0, 14, 9],
      [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 13, 3, 9, 8, 6],
      [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
      [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],
     [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
      [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
      [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
      [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],
     [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
      [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
      [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
      [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],
     [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
      [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
      [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
      [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]]
P = [0, 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11,
     4, 25]


def divide_to_64_bite(str):  # 将比特消息划分为64bite一组，并返回
    result = []
    divide_num = len(str) // 64  # 分组数量
    for i in range(divide_num):
        result.append(str[(i * 64):((i + 1) * 64)])

    return result


def divide_to_6_bite(str):  # 将比特消息划分为6bite一组，并返回
    result = []
    divide_num = len(str) // 6  # 分组数量
    for i in range(divide_num):
        result.append(str[(i * 6):((i + 1) * 6)])

    return result


def F(str, key):  # 返回的字符中，开头没有t占位
    str = 't' + str
    # E扩展置换
    E_translate_str = ""
    for i in range(1, 49):
        E_translate_str += str[E[i]]

    # 密钥加
    if (len(E_translate_str) != 48 or len(key) != 48):  # 先检测str和key是否都是48位
        print("str和key须有都是48位")
        # print(E_translate_str,key)
        assert False

    # 按位异或
    temp = int(E_translate_str, 2) ^ int(key, 2)
    key_add_str = f'{temp:048b}'

    # S盒压缩变换
    divide_to_6_arr = divide_to_6_bite(key_add_str)  # 先分成6位一组

    S_translate_str = ""
    for step in range(len(divide_to_6_arr)):  # 每一组都需要查表转换
        divide_to_6_arr_contain = divide_to_6_arr[step]  # 取每一组的内容
        temp_i = divide_to_6_arr_contain[0] + divide_to_6_arr_contain[5]
        temp_j = divide_to_6_arr_contain[1:5]
        i = int(temp_i, 2)
        j = int(temp_j, 2)
        S_translate_str += f'{S[step][i][j]:04b}'  # 查S表得到第i行第j列的数字，并转换成2进制

    S_translate_str = 't' + S_translate_str
    # P盒置换
    P_translate_str = ""
    for i in range(1, 33):
        P_translate_str += S_translate_str[P[i]]

    return P_translate_str


def product_key(str):
    str_bite = ""
    for i in str:  # 把每一个字符变成8位的2进制表示
        str_bite += f'{ord(i):08b}'

    str_bite = 't' + str_bite
    # PC-1置换
    PC1_translate_str = ""
    for i in range(1, 57):
        PC1_translate_str += str_bite[PC1[i]]

    PC1_C = []
    PC1_D = []
    PC1_C.append(PC1_translate_str[0:28])
    PC1_D.append(PC1_translate_str[28:])

    # 生成16组C和D
    for step in range(0, 16):
        left_move_num = left_move_arr[step]
        result_C = PC1_C[step][left_move_num:] + PC1_C[step][0:left_move_num]
        result_D = PC1_D[step][left_move_num:] + PC1_D[step][0:left_move_num]
        PC1_C.append(result_C)
        PC1_D.append(result_D)

    C_add_D = []
    for step in range(1, 17):  # 对新生成的C和D，进行组合
        C_add_D.append(PC1_C[step] + PC1_D[step])

    result = []
    # PC-2置换
    for step in range(0, 16):  # 对新生成的C和D，进行PC2置换
        C_add_D[step] = 't' + C_add_D[step]
        temp_result = ""
        for i in range(1, 49):
            temp_result += C_add_D[step][PC2[i]]
        result.append(temp_result)

    return result


def DES_encrypto(str, key, IV):
    # IV以16进制形式输入
    IV_bite = ""
    for i in IV:  # 把每一个字符变成8位的2进制表示
        IV_bite += f'{ord(i):08b}'

    # 将输入明文按64位分组
    str_bite = ""
    for i in str:  # 把每一个字符变成16位的2进制表示
        str_bite += f'{ord(i):016b}'

    while (len(str_bite) % 64 != 0):  # 不足64位的倍数时补0
        str_bite += '0'

    divide_arr = divide_to_64_bite(str_bite)

    # 将输入的密钥生成16组子密钥
    if len(key) != 8:
        print("密钥长度需要为8")
        assert False

    key_arr = product_key(key)

    # 对每一组都进行加密
    encrypto_str = ""
    for divide_arr_contain in divide_arr:
        # 先进行与上一组密文结果的异或
        temp_contain = int(divide_arr_contain, 2) ^ int(IV_bite, 2)
        divide_arr_contain = f'{temp_contain:064b}'

        # 用t占位，方便后面下标的处理
        divide_arr_contain = 't' + divide_arr_contain

        # IP置换
        IP_translate_str = "t"
        for i in range(1, 65):
            IP_translate_str += divide_arr_contain[IP[i]]

        L = []
        R = []
        L.append(IP_translate_str[1:33])
        R.append(IP_translate_str[33:65])

        for step in range(0, 15):
            L.append(R[step])
            temp_str1 = L[step]
            temp_str2 = F(R[step], key_arr[step])
            temp_str_num = int(temp_str1, 2) ^ int(temp_str2, 2)
            temp_str = f'{temp_str_num:032b}'
            R.append(temp_str)

        temp_str1 = L[15]
        temp_str2 = F(R[15], key_arr[15])
        temp_str_num = int(temp_str1, 2) ^ int(temp_str2, 2)
        temp_str = f'{temp_str_num:032b}'
        L.append(temp_str)
        R.append(R[15])

        # IP逆置换
        L_add_R = 't' + L[16] + R[16]
        IP_reverse_translate_str = ""
        for i in range(1, 65):
            IP_reverse_translate_str += L_add_R[IP_[i]]

        encrypto_str += IP_reverse_translate_str

        IV_bite = IP_reverse_translate_str

    result_str = ""
    for i in range(0, len(encrypto_str), 8):
        result_str += chr(int(encrypto_str[i:i + 8], 2))

    str_16 = ""

    for i in result_str:  # 把每一个字符变成8位的2进制表示
        str_16 += f'{ord(i):02x}'

    return str_16


def DES_decrypto(str_1, key, IV):
    str = ''
    for i in range(0, len(str_1), 2):
        str += chr(int(str_1[i:i + 2], 16))

    # IV以16进制形式输入
    IV_bite = ""
    for i in IV:  # 把每一个字符变成8位的2进制表示
        IV_bite += f'{ord(i):08b}'

    # 将输入明文按64位分组
    str_bite = ""
    for i in str:  # 把每一个字符变成8位的2进制表示
        str_bite += f'{ord(i):08b}'

    if len(str_bite) % 64 != 0:
        print("密文输入有错")
        assert False

    divide_arr = divide_to_64_bite(str_bite)

    # 将输入的密钥生成16组子密钥
    if len(key) != 8:
        print("密钥长度需要为8")
        assert False

    key_arr = product_key(key)

    # 对每一组都进行解密
    decrypto_str = ""
    for divide_arr_contain in divide_arr:
        # 暂时保存当前密文，用于最后和IV异或运算
        temp_current_contain = divide_arr_contain

        # 用t占位，方便后面下标的处理
        divide_arr_contain = 't' + divide_arr_contain

        # IP置换
        IP_translate_str = "t"
        for i in range(1, 65):
            IP_translate_str += divide_arr_contain[IP[i]]

        L = []
        R = []
        L.append(IP_translate_str[1:33])
        R.append(IP_translate_str[33:65])

        for step in range(0, 15):
            temp_str1 = L[step]
            temp_str2 = F(R[step], key_arr[15 - step])
            temp_str_num = int(temp_str1, 2) ^ int(temp_str2, 2)
            temp_str = f'{temp_str_num:032b}'
            R.append(temp_str)
            L.append(R[step])

        temp_str1 = L[15]
        temp_str2 = F(R[15], key_arr[0])
        temp_str_num = int(temp_str1, 2) ^ int(temp_str2, 2)
        temp_str = f'{temp_str_num:032b}'
        L.append(temp_str)
        R.append(R[15])

        # IP逆置换
        L_add_R = 't' + L[16] + R[16]
        IP_reverse_translate_str = ""
        for i in range(1, 65):
            IP_reverse_translate_str += L_add_R[IP_[i]]

        # 先进行与上一组密文结果的异或
        temp_contain = int(IP_reverse_translate_str, 2) ^ int(IV_bite, 2)
        IP_reverse_translate_str = f'{temp_contain:064b}'
        IV_bite = temp_current_contain

        decrypto_str += IP_reverse_translate_str

    result_str = ""
    for i in range(0, len(decrypto_str), 16):
        if int(decrypto_str[i:i + 16], 2) == 0:
            continue
        if int(decrypto_str[i:i + 16], 2) <= 255:
            h_t = f'{int(decrypto_str[i:i + 16], 2):02x}'
            h_t = "\\u00" + h_t
            h_st = h_t.encode('utf-8')
            h_st = h_st.decode("unicode_escape")
        else:
            h_t = f'{int(decrypto_str[i:i + 16], 2):04x}'
            h_t = "\\u" + h_t
            h_st = h_t.encode('utf-8')
            h_st = h_st.decode("unicode_escape")
        result_str += h_st

    return result_str
```

## CommunicationRSA.py 文件

修改后的RSA加密，用于方便实现通信

```python
# coding:utf-8
import random


def fast_mod(bottom_num, power_num, mod_num):  # 快速幂算法
    result = 1
    while power_num != 0:
        if power_num % 2 == 1:
            power_num -= 1
            result = (result * bottom_num) % mod_num
        if power_num == 0:
            break

        power_num = power_num // 2
        bottom_num = (bottom_num * bottom_num) % mod_num
    return result


def Euclidean_algorithm(a, b):  # 欧几里得算法，即辗转相除法，求最大公因数
    if a < b:  # 把较大的数放在a的位置上
        temp = a
        a = b
        b = temp
    flag = 1
    while flag != 0:
        flag = a % b
        a = b
        b = flag
    return a


def Fermat_judge(judge_num, security_num):  # 判断是否为伪素数，Fermat素性检验，返回True或者False
    have_select_num = []  # 存放已经使用过的检验数
    b = 0
    flag = True  # 标记judge_num是否为素数，True时候为素数
    for step in range(0, security_num):  # 重复security_num次检验
        for i in range(2, judge_num - 1):  # 挑选一个检验数
            if (i not in have_select_num) and (Euclidean_algorithm(i, judge_num) == 1):
                b = i
                have_select_num.append(i)
                break

        r = fast_mod(b, judge_num - 1, judge_num)

        if r != 1:  # r不等于1时，则judge_num为合数
            flag = False
            break

    return flag


def Miller_Rabin_judge(judge_num, security_num):  # 判断是否为强伪素数，Miller_Rabin素性检验，返回True或者False
    have_select_num = []  # 存放已经使用过的检验数
    b = 0
    flag = True  # 标记judge_num是否为素数，True时候为素数
    for step in range(0, security_num):  # 重复security_num次检验
        for i in range(2, judge_num - 1):  # 挑选一个检验数
            if (i not in have_select_num) and (Euclidean_algorithm(i, judge_num) == 1):
                b = i
                have_select_num.append(i)
                break

        s = 1
        t = 1
        while True:
            if (judge_num - 1) % pow(2, s) == 0:
                t = (judge_num - 1) // pow(2, s)
                if t % 2 == 1:
                    break
            s += 1

        r0 = fast_mod(b, t, judge_num)

        for i in range(0, s):
            if i == s - 1 and r0 != judge_num - 1:
                flag = False
                return flag

            if r0 == 1 or r0 == judge_num - 1:
                break
            else:
                temp = (r0 * r0) % judge_num
                r0 = temp

    return flag


def product_num(num_len):  # 生成长度为num_len的一个随机数
    result = "1"
    while True:
        if len(result) != num_len:  # 长度不够时候继续添加长度
            result += random.choice(['0', '1'])
        else:
            if int(result, 2) % 2 != 1:  # 如果生成的数不是奇数，就再生成一个
                result = "1"
            else:
                break
    return int(result, 2)


def product_prime_num(num_len):  # 生成长度为num_len的一个素数
    prime_num = 1
    while True:
        prime_num = product_num(num_len)
        if Fermat_judge(prime_num, 1):
            if Miller_Rabin_judge(prime_num, 10):
                break
        else:
            continue

    return prime_num


def reverse_element(a, b):  # 利用sa+tb=1，即利用欧几里得算法的逆过程，求逆元，这里返回的是s，相当于是求a在模b情况下的逆元
    s0 = 1
    s1 = 0
    t0 = 0
    t1 = 1
    r1 = max(a, b)
    r0 = min(a, b)
    q1 = r1 // r0

    s2 = 0
    t2 = 0
    q0 = 0
    while True:
        s2 = s0 - q1 * s1
        t2 = t0 - q1 * t1
        temp = r1 % r0
        r1 = max(r0, temp)
        r0 = min(r0, temp)

        if r0 == 0:
            if t1 > 0:
                return t1
            else:
                return t1 + max(a, b)

        q1 = r1 // r0

        s0 = s1
        t0 = t1
        s1 = s2
        t1 = t2


def produce_RSA():  # 生成n,e,d
    while True:  # 生成两个不相等的大素数
        p = product_prime_num(512)
        q = product_prime_num(512)
        if p != q:
            break
        else:
            p = product_prime_num(512)
            q = product_prime_num(512)

    n = p * q
    phi = (p - 1) * (q - 1)  # 计算p*q的欧拉函数，结果是phi

    e = random.randint(2, phi - 1)
    while True:  # 选取e，满足和phi互素
        if Euclidean_algorithm(e, phi) == 1:
            break
        else:
            e = random.randint(2, phi - 1)

    d = reverse_element(e, phi)

    n = str(n)
    e = str(e)
    d = str(d)

    return (n, e, d)


def str_to_16(str):
    str_num = ""
    for i in str:  # 先把密文转16进制，再在10进制的情况下，进行运算
        str_num += f'{ord(i):02x}'
    return str_num


def RSA_encode(n, e, plaintext):  # RSA加密函数
    e = int(e, 10)
    n = int(n, 10)
    # 下面对密文进行加密
    cryptotest = fast_mod(int(plaintext, 16), e, n)

    return hex(cryptotest)


def str16_to_str(plaintext_16_str):
    plaintext = ""
    for i in range(0, len(plaintext_16_str), 2):
        plaintext += chr(int(plaintext_16_str[i:i + 2], 16))

    return plaintext


def RSA_decode(cryptotest, d, n):  # RSA解密函数
    plaintext = ""
    cryptotest = int(cryptotest, 16)  # 把cryptotest, d, n转成数字
    d = int(d, 10)
    n = int(n, 10)
    plaintext_num = fast_mod(cryptotest, d, n)
    plaintext_16_str = hex(plaintext_num)
    plaintext_16_str = plaintext_16_str[2:]  # 去掉前面的0x，避免报错

    return plaintext_16_str
```
