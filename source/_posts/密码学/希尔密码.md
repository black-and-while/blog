---
title: 希尔(Hill Cipher)密码
date: '2022/1/23 23:15:01'
categories:
  - - 密码学
description: 关于希尔(Hill Cipher)密码的加解密算法实现、密钥破解及其脚本
abbrlink: 62ed98f1
tags:
---

# 希尔(Hill Cipher)密码

## 简介

希尔密码（Hill Cipher）是运用基本矩阵论原理的替换密码，由Lester S. Hill在1929年发明。每个字母当作26进制数字：A=0, B=1, C=2... 一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26。

希尔加密算法的基本思想是，将d个明文字母通过线性变换将它们转换为d个密文字母。解密只要作一次逆变换就可以了，密钥就是变换矩阵本身。

## 加密算法实现

先把输入的明文全部转成小写，然后转换成数字，与密钥矩阵相乘得到结果

```python
def HillEncrypto(str, input_key, length):  # 加密函数
    plaintext = ''
    for i in range(0, length):  # 输入明文转小写
        if (str[i] >= 'A' and str[i] <= 'Z'):
            plaintext += chr(ord('a') + ord(str[i]) - ord('A'))
        else:
            plaintext += str[i]

    arr = []  # 输入明文转数字
    for i in range(0, length):
        arr.append(ord(plaintext[i]) - 97)

    key = input_key

    cryptotest = []

    for i in range(0, length):  # 进行加密，矩阵相乘
        temp_num = 0
        for j in range(0, length):
            temp_num += arr[j] * key[j][i]
        temp_num %= 26
        cryptotest.append(temp_num)

    return cryptotest
```

## 解密算法实现

（1）定义了计算行列式的函数 DeterminantValue(arr)，通过进行递归运算，求子行列式的值，直到行列式阶数为 1 时为终止条件，向上递归，最终得到当前行列式的值。
```python
def DeterminantValue(arr):  # 计算行列式
    arr_row = len(arr)
    arr_list = len(arr[0])

    if arr_row == 1 and arr_list == 1:
        return arr[0][0]
    else:
        result = 0
        for i in range(0, arr_row):
            for j in range(0, arr_list):
                son_determinant = [[] for i in range(0, arr_row - 1)]  # 求去掉第i行第j列的矩阵son_determinant
                point_son_x = 0
                for x in range(0, arr_row):
                    for y in range(0, arr_list):
                        if x == i or y == j:
                            continue
                        else:
                            son_determinant[point_son_x].append(arr[x][y])
                    if x != i:
                        point_son_x += 1
                result += arr[0][j] * pow(-1, 1 + j + 1) * DeterminantValue(son_determinant)
        return result
```

（2）定义了求逆矩阵的函数 DeterminantInverse(arr)，通过先求当前矩阵的伴随矩阵，然后把伴随矩阵与当前矩阵的逆（在模 26 的情况下）相乘，最后进行矩阵转置，就能得到逆矩阵。
```python
def DeterminantInverse(arr):  # 求矩阵的逆
    arr_row = len(arr)
    arr_list = len(arr[0])
    temp_inverse_arr = [[] for i in range(0, arr_row)]  # 转置前的逆矩阵

    inverse_element = -1  # 行列式的逆元
    arr_value = DeterminantValue(arr)
    for i in range(0, 26):
        if arr_value * i % 26 == 1:
            inverse_element = i
            break

    if inverse_element == -1:    # 逆元不存在时候报错
        print("不存在逆元，矩阵不可逆")
        assert False

    for i in range(0, arr_row): # 在模26的情况下，先求伴随矩阵temp_inverse_arr，然后*对应的逆元，最终得到逆矩阵
        for j in range(0, arr_list):    # 求伴随矩阵
            son_determinant = [[] for i in range(0, arr_row - 1)]
            point_son_x = 0
            for x in range(0, arr_row):
                for y in range(0, arr_list):
                    if x == i or y == j:
                        continue
                    else:
                        son_determinant[point_son_x].append(arr[x][y])
                if x != i:
                    point_son_x += 1

            temp_value = DeterminantValue(son_determinant) * pow(-1, i + 1 + j + 1) % 26
            temp_value = (temp_value + 26) % 26
            temp_value = temp_value * inverse_element % 26      # 乘对应的逆元

            temp_inverse_arr[i].append(temp_value)

    inverse_arr = [[] for i in range(0, arr_row)]  # 转置后的逆矩阵，下面进行矩阵转置

    point_x = 0
    for i in range(0, arr_row):
        for j in range(0, arr_list):
            inverse_arr[point_x].append(temp_inverse_arr[j][i])
        point_x += 1

    return inverse_arr
```

（3）在解密函数 HillDecrypto(arr)中，通过 DeterminantInverse()函数求密钥矩阵的逆矩阵，再使用加密函数 HillEncrypto()进行运算，就能实现解密的过程。

```python
def HillDecrypto(input_str, input_key, length):  # 解密函数
    key = copy.deepcopy(input_key)
    inverse_key = DeterminantInverse(key)
    plaintext = HillEncrypto(input_str, inverse_key, length)

    return plaintext
```

## 密钥破解算法

如果已知大量的明文和密文对，通过求明文矩阵的逆，与密文矩阵相乘，就能得到密钥矩阵

```python
def HillAttack(input_plaintext, input_cryptotest, key_len):
    plaintext = ''
    for i in range(0, len(input_plaintext)):  # 输入明文转小写
        if (input_plaintext[i] >= 'A' and input_plaintext[i] <= 'Z'):
            plaintext += chr(ord('a') + ord(input_plaintext[i]) - ord('A'))
        else:
            plaintext += input_plaintext[i]

    cryptotest = ''
    for i in range(0, len(input_cryptotest)):  # 输入密文转小写
        if (input_cryptotest[i] >= 'A' and input_cryptotest[i] <= 'Z'):
            cryptotest += chr(ord('a') + ord(input_cryptotest[i]) - ord('A'))
        else:
            cryptotest += input_cryptotest[i]

    if len(cryptotest) < key_len * key_len or len(plaintext) < key_len * key_len:
        print("输入明文或密文过短，无法破解")
        assert False

    arr_plaint = [[] for i in range(key_len)]  # 输入明文转数字
    point_x = 0
    count = 0
    for i in range(0, len(input_plaintext)):
        point_x = i // key_len
        arr_plaint[point_x].append(ord(plaintext[i]) - 97)
        count += 1
        if count == key_len * key_len:
            break

    arr_crypto = [[] for i in range(key_len)]  # 输入密文转数字
    point_x = 0
    count = 0
    for i in range(0, len(input_cryptotest)):
        point_x = i // key_len
        arr_crypto[point_x].append(ord(cryptotest[i]) - 97)
        count += 1
        if count == key_len * key_len:
            break

    # 先求明文矩阵的逆，与密文矩阵相乘，得到密钥矩阵
    arr_plaint_inverse = DeterminantInverse(arr_plaint)
    arr_key = [[] for i in range(key_len)] # 密钥数组

    for i in range(key_len):
        for j in range(key_len):
            temp = 0
            for t in range(key_len):
                temp += arr_plaint_inverse[i][t] * arr_crypto[t][j]
            temp %= 26
            arr_key[i].append(temp)

    return arr_key
```

## 完整脚本
```python
import copy


def DeterminantValue(arr):  # 计算行列式
    arr_row = len(arr)
    arr_list = len(arr[0])

    if arr_row == 1 and arr_list == 1:
        return arr[0][0]
    else:
        result = 0
        for i in range(0, arr_row):
            for j in range(0, arr_list):
                son_determinant = [[] for i in range(0, arr_row - 1)]  # 求去掉第i行第j列的矩阵son_determinant
                point_son_x = 0
                for x in range(0, arr_row):
                    for y in range(0, arr_list):
                        if x == i or y == j:
                            continue
                        else:
                            son_determinant[point_son_x].append(arr[x][y])
                    if x != i:
                        point_son_x += 1
                result += arr[0][j] * pow(-1, 1 + j + 1) * DeterminantValue(son_determinant)
        return result


def DeterminantInverse(arr):  # 求矩阵的逆
    arr_row = len(arr)
    arr_list = len(arr[0])
    temp_inverse_arr = [[] for i in range(0, arr_row)]  # 转置前的逆矩阵

    inverse_element = -1  # 行列式的逆元
    arr_value = DeterminantValue(arr)
    for i in range(0, 26):
        if arr_value * i % 26 == 1:
            inverse_element = i
            break

    if inverse_element == -1:    # 逆元不存在时候报错
        print("不存在逆元，矩阵不可逆")
        assert False

    for i in range(0, arr_row): # 在模26的情况下，先求伴随矩阵temp_inverse_arr，然后*对应的逆元，最终得到逆矩阵
        for j in range(0, arr_list):    # 求伴随矩阵
            son_determinant = [[] for i in range(0, arr_row - 1)]
            point_son_x = 0
            for x in range(0, arr_row):
                for y in range(0, arr_list):
                    if x == i or y == j:
                        continue
                    else:
                        son_determinant[point_son_x].append(arr[x][y])
                if x != i:
                    point_son_x += 1

            temp_value = DeterminantValue(son_determinant) * pow(-1, i + 1 + j + 1) % 26
            temp_value = (temp_value + 26) % 26
            temp_value = temp_value * inverse_element % 26      # 乘对应的逆元
            temp_inverse_arr[i].append(temp_value)

    inverse_arr = [[] for i in range(0, arr_row)]  # 转置后的逆矩阵，下面进行矩阵转置

    point_x = 0
    for i in range(0, arr_row):
        for j in range(0, arr_list):
            inverse_arr[point_x].append(temp_inverse_arr[j][i])
        point_x += 1

    return inverse_arr


def HillEncrypto(str, input_key, length):  # 加密函数
    plaintext = ''
    for i in range(0, length):  # 输入明文转小写
        if (str[i] >= 'A' and str[i] <= 'Z'):
            plaintext += chr(ord('a') + ord(str[i]) - ord('A'))
        else:
            plaintext += str[i]

    arr = []  # 输入明文转数字
    for i in range(0, length):
        arr.append(ord(plaintext[i]) - 97)

    key = input_key

    cryptotest = []

    for i in range(0, length):  # 进行加密，矩阵相乘
        temp_num = 0
        for j in range(0, length):
            temp_num += arr[j] * key[j][i]
        temp_num %= 26
        cryptotest.append(temp_num)

    return cryptotest


def HillDecrypto(input_str, input_key, length):  # 解密函数
    key = copy.deepcopy(input_key)
    inverse_key = DeterminantInverse(key)
    plaintext = HillEncrypto(input_str, inverse_key, length)

    return plaintext


def HillAttack(input_plaintext, input_cryptotest, key_len):
    plaintext = ''
    for i in range(0, len(input_plaintext)):  # 输入明文转小写
        if (input_plaintext[i] >= 'A' and input_plaintext[i] <= 'Z'):
            plaintext += chr(ord('a') + ord(input_plaintext[i]) - ord('A'))
        else:
            plaintext += input_plaintext[i]

    cryptotest = ''
    for i in range(0, len(input_cryptotest)):  # 输入密文转小写
        if (input_cryptotest[i] >= 'A' and input_cryptotest[i] <= 'Z'):
            cryptotest += chr(ord('a') + ord(input_cryptotest[i]) - ord('A'))
        else:
            cryptotest += input_cryptotest[i]

    if len(cryptotest) < key_len * key_len or len(plaintext) < key_len * key_len:
        print("输入明文或密文过短，无法破解")
        assert False

    arr_plaint = [[] for i in range(key_len)]  # 输入明文转数字
    point_x = 0
    count = 0
    for i in range(0, len(input_plaintext)):
        point_x = i // key_len
        arr_plaint[point_x].append(ord(plaintext[i]) - 97)
        count += 1
        if count == key_len * key_len:
            break

    arr_crypto = [[] for i in range(key_len)]  # 输入密文转数字
    point_x = 0
    count = 0
    for i in range(0, len(input_cryptotest)):
        point_x = i // key_len
        arr_crypto[point_x].append(ord(cryptotest[i]) - 97)
        count += 1
        if count == key_len * key_len:
            break

    # 先求明文矩阵的逆，与密文矩阵相乘，得到密钥矩阵
    arr_plaint_inverse = DeterminantInverse(arr_plaint)
    arr_key = [[] for i in range(key_len)] # 密钥数组

    for i in range(key_len):
        for j in range(key_len):
            temp = 0
            for t in range(key_len):
                temp += arr_plaint_inverse[i][t] * arr_crypto[t][j]
            temp %= 26
            arr_key[i].append(temp)

    return arr_key


if __name__ == '__main__':
    input_number = input("请选择方式：输入1为加密 输入2为解密 输入3为已知明文攻击\n")
    if input_number == "1":
        plaintext = input("请输入明文：")
        length = len(plaintext)
        print("请输入密钥：")
        input_key = [[0] * length] * length
        for i in range(length):
            input_key[i] = input().split(' ')
            input_key[i] = [int(j) for j in input_key[i]]
        arr = HillEncrypto(plaintext, input_key, length)
        encrypto_text = ""
        for i in arr:
            encrypto_text += chr(ord('a')+i)
        print(f"明文加密后为：{encrypto_text}")
    elif input_number == "2":
        cryptotest = input("请输入密文：")
        length = len(cryptotest)
        print("请输入密钥：")
        input_key = [[0] * length] * length
        for i in range(length):
            input_key[i] = input().split(' ')
            input_key[i] = [int(j) for j in input_key[i]]
        arr = HillDecrypto(cryptotest, input_key, length)
        decrypto_text = ""
        for i in arr:
            decrypto_text += chr(ord('a')+i)
        print(f"密文解密后为：{decrypto_text}")
    elif input_number == "3":
        key_len = int(input("请输入密钥长度："))
        plaintext = input("请输入明文：")
        length = len(plaintext)
        cryptotest = input("请输入密文：")
        length = len(cryptotest)
        print(f"密钥矩阵为：{HillAttack(plaintext, cryptotest, key_len)}")
```