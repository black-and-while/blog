---
title: 维吉利亚密码
date: '2022/1/23 23:15:01'
categories:
  - - 密码学
description: 关于维吉利亚密码的加解密算法实现、密钥破解及其脚本
abbrlink: ba619c97
tags:
---

# 维吉利亚密码

## 简介
维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。

在单一恺撒密码的基础上，法国外交家布莱斯·德·维吉尼亚（Blaise de Vigenère）发明了一种方法来对同一条信息中的不同字母用不同的密码进行加密。这样，同样的E在一个位置可能被M所取代，而在另一个位置的E则有可能以K的面目出现。这样，就可以防止任何人利用频率分析法解密该条信息。

维吉尼亚密码引入了“密钥”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。

假如当选定RELATIONS作为密钥时，对如下明文加密：

TO BE OR NOT TO BE THAT IS THE QUESTION

> 加密过程：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K

依此类推，得出对应关系如下：

密钥:RELAT IONSR ELATI ONSRE LATIO NSREL

明文:TOBEO RNOTT OBETH ATIST HEQUE STION

密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY

参考来源：[https://www.cnblogs.com/linuxbug/p/5708584.html](https://www.cnblogs.com/linuxbug/p/5708584.html)


## 加密算法实现

这里把密钥全部转换成小写，然后按照凯撒加密的方式，利用密钥进行加密，其中字母在大小写字母的区间进行移位加密，数字和特殊符号不进行移位

```python
def VigenereEncrypto(plaintext, input_key):  # 加密函数
    key = ""
    for i in range(0, len(input_key)):  # 密钥转小写
        if (input_key[i] >= 'A' and input_key[i] <= 'Z'):
            key += chr(ord('a') + ord(input_key[i]) - ord('A'))
        else:
            key += input_key[i]

    count = 0
    cryptotest = ""
    for i in range(0, len(plaintext)):  # 加密，分别在大小写字母的区间进行移位加密，数字和特殊符号不进行移位
        if plaintext[i] >= 'A' and plaintext[i] <= 'Z':
            temp_num = ord(plaintext[i]) - 65
            temp_num = (temp_num + ord(key[count]) - 97) % 26
            cryptotest += chr(temp_num + 65)
        elif plaintext[i] >= 'a' and plaintext[i] <= 'z':
            temp_num = ord(plaintext[i]) - 97
            temp_num = (temp_num + ord(key[count]) - 97) % 26
            cryptotest += chr(temp_num + 97)
        else:
            cryptotest += plaintext[i]
        count = (count + 1 + len(key)) % len(key)

    return cryptotest
```
## 解密算法实现

这里把密钥全部转换成小写，然后按照凯撒加密的方式，利用密钥进行解密，与加密过程相反，其中字母在大小写字母的区间进行移位加密，数字和特殊符号不进行移位

```python
def VigenereDecrypto(cryptotest, input_key):  # 解密函数
    key = ""
    for i in range(0, len(input_key)):  # 密钥转小写
        if (input_key[i] >= 'A' and input_key[i] <= 'Z'):
            key += chr(ord('a') + ord(input_key[i]) - ord('A'))
        else:
            key += input_key[i]

    count = 0
    plaintext = ""
    for i in range(0, len(cryptotest)):  # 解密
        if not ((cryptotest[i] >= 'A' and cryptotest[i] <= 'Z') or (cryptotest[i] >= 'a' and cryptotest[i] <= 'z')):
            plaintext += cryptotest[i]
            continue
        if cryptotest[i] >= 'A' and cryptotest[i] <= 'Z':
            temp_num = ord(cryptotest[i]) - 65
            temp_num = (temp_num - (ord(key[count]) - 97) + 26) % 26
            plaintext += chr(temp_num + 65)
        elif cryptotest[i] >= 'a' and cryptotest[i] <= 'z':
            temp_num = ord(cryptotest[i]) - 97
            temp_num = (temp_num - (ord(key[count]) - 97) + 26) % 26
            plaintext += chr(temp_num + 97)
        else:
            plaintext += cryptotest[i]
        count = (count + 1 + len(key)) % len(key)

    return plaintext
```
## 利用重合指数法和拟重合指数法确定密钥

使用重合指数法先计算出密钥长度，再使用拟重合指数法确定具体密钥。

（1）重合指数法： 从长度为 1 开始，依次尝试不同长度的分组，计算对应的重合指数的值，从中选 择最接近 0.065 的情况，则推断这个是密钥长度。

（2）拟重合指数法： 确定密钥长度之后，把密文按照长度进行分组。 对于每一个分组，统计每个分组中的字母出现频率，用穷举 26 个字母的方法， 计算在不同偏移的情况下的拟重合指数的值，从中选择最接近 0.065 的偏移，则 确定该组的偏移，从而确定各组的偏移，最后组合成完整密钥。

```python
def VigenereSolveCrypto(input_str):  # 重合指数法解密函数
    # 密文转小写
    cryptotest = ""
    for i in range(0, len(input_str)):
        if (input_str[i] >= 'A' and input_str[i] <= 'Z'):
            cryptotest += chr(ord('a') + ord(input_str[i]) - ord('A'))
        else:
            if (input_str[i] >= 'a' and input_str[i] <= 'z'):
                cryptotest += input_str[i]

    # 确定密钥长度
    result_len = 1
    result_rate = 99999

    for str_len in range(1, len(cryptotest) + 1):  # 分组长度
        divide_arr = ["" for i in range(0, str_len)]  # 存储分组后的密文
        temp_point = 0
        for i in cryptotest:  # 进行分组
            divide_arr[temp_point] += i
            temp_point = (temp_point + 1) % str_len
        # print(divide_arr)
        divide_rate = [0 for i in range(0, str_len)]  # 存储分组后的密文的重合指数
        for i in range(0, str_len):  # 遍历每一个分组
            divide_arr_count = [0 for i in range(0, 26)]  # 存储第i分组的各个字母的频率
            for now_chr in divide_arr[i]:  # 统计在第i分组中，每个字母出现的次数
                divide_arr_count[ord(now_chr) - ord('a')] += 1
            # print(divide_arr_count)
            now_total_rate = 0
            if (len(divide_arr[i]) == 0) or (len(divide_arr[i]) - 1 == 0):  # 分组后的字符串，长度过小情况下，得不到正常的总概率和，舍弃该情况
                continue
            for j in range(0, 26): # 计算密文中，2个随机字母相同的概率，将26个字母的结果相加得到总概率和
                temp = (divide_arr_count[j] * (divide_arr_count[j] - 1)) / (
                        len(divide_arr[i]) * (len(divide_arr[i]) - 1))
                now_total_rate += temp
            divide_rate[i] = now_total_rate

        now_rate = 0
        for i in range(0, str_len): # 计算每个分组的总概率和与0.065的差值，然后取平均值，得到当前分组长度为str_len的情况下的平均概率
            now_rate += abs(divide_rate[i] - 0.065)
        now_rate /= (str_len)

        if now_rate < result_rate:  # 每次都与当前的频率进行比较，挑选出最优方案
            result_len = str_len
            result_rate = now_rate
    print(f"密钥长度是：{result_len}")

    right_divide_arr = ["" for i in range(0, result_len)]  # 存储分组后的密文
    temp_point = 0
    for i in cryptotest:
        right_divide_arr[temp_point] += i
        temp_point = (temp_point + 1) % result_len

    # 接下来对密钥进行破解
    letter_frequence = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966,
                        0.00153, 0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987,
                        0.06327, 0.09056, 0.02758, 0.00978, 0.0236, 0.0015, 0.01974, 0.00074]

    key_str = ""

    for i in range(0, result_len):  # 遍历每一个分组的密文，破解对应的密钥
        now_letter_count = [0 for i in range(0, 26)]
        for now_chr in right_divide_arr[i]: # 统计在第i分组中，每个字母出现的次数
            now_letter_count[ord(now_chr) - ord('a')] += 1

        may_key = [0 for i in range(0, 26)]

        for step in range(0, 26):  # 遍历可能的key
            now_may_rate = 0
            for j in range(0, 26):  # 遍历26个字母，计算 正确概率*（当前第j字母+移位步数step）的概率，然后对26个字母的结果求和
                point = (j + step) % 26
                temp = letter_frequence[j] * now_letter_count[point]
                now_may_rate += temp
            now_may_rate /= len(right_divide_arr[i])
            may_key[step] = now_may_rate

        result_step = 1
        result_key_rate = 999
        for i in range(0, 26):  # 比较在不同移位步数step的情况下，与0.065的接近程度，得到当前的正确移位数
            if abs(may_key[i] - 0.065) < abs(result_key_rate - 0.065):
                result_step = i
                result_key_rate = may_key[i]
        key_str += chr(result_step + ord('a'))

    print(f"密钥是：{key_str}")
    print(f"解密后的明文是：{VigenereDecrypto(input_str, key_str)}")
```

## 完整脚本
```python
def VigenereEncrypto(plaintext, input_key):  # 加密函数
    key = ""
    for i in range(0, len(input_key)):  # 密钥转小写
        if (input_key[i] >= 'A' and input_key[i] <= 'Z'):
            key += chr(ord('a') + ord(input_key[i]) - ord('A'))
        else:
            key += input_key[i]

    count = 0
    cryptotest = ""
    for i in range(0, len(plaintext)):  # 加密，分别在大小写字母的区间进行移位加密，数字和特殊符号不进行移位
        if plaintext[i] >= 'A' and plaintext[i] <= 'Z':
            temp_num = ord(plaintext[i]) - 65
            temp_num = (temp_num + ord(key[count]) - 97) % 26
            cryptotest += chr(temp_num + 65)
        elif plaintext[i] >= 'a' and plaintext[i] <= 'z':
            temp_num = ord(plaintext[i]) - 97
            temp_num = (temp_num + ord(key[count]) - 97) % 26
            cryptotest += chr(temp_num + 97)
        else:
            cryptotest += plaintext[i]
        count = (count + 1 + len(key)) % len(key)

    return cryptotest


def VigenereDecrypto(cryptotest, input_key):  # 解密函数
    key = ""
    for i in range(0, len(input_key)):  # 密钥转小写
        if (input_key[i] >= 'A' and input_key[i] <= 'Z'):
            key += chr(ord('a') + ord(input_key[i]) - ord('A'))
        else:
            key += input_key[i]

    count = 0
    plaintext = ""
    for i in range(0, len(cryptotest)):  # 解密
        if not ((cryptotest[i] >= 'A' and cryptotest[i] <= 'Z') or (cryptotest[i] >= 'a' and cryptotest[i] <= 'z')):
            plaintext += cryptotest[i]
            continue
        if cryptotest[i] >= 'A' and cryptotest[i] <= 'Z':
            temp_num = ord(cryptotest[i]) - 65
            temp_num = (temp_num - (ord(key[count]) - 97) + 26) % 26
            plaintext += chr(temp_num + 65)
        elif cryptotest[i] >= 'a' and cryptotest[i] <= 'z':
            temp_num = ord(cryptotest[i]) - 97
            temp_num = (temp_num - (ord(key[count]) - 97) + 26) % 26
            plaintext += chr(temp_num + 97)
        else:
            plaintext += cryptotest[i]
        count = (count + 1 + len(key)) % len(key)

    return plaintext


def VigenereSolveCrypto(input_str):  # 重合指数法解密函数
    # 密文转小写
    cryptotest = ""
    for i in range(0, len(input_str)):
        if (input_str[i] >= 'A' and input_str[i] <= 'Z'):
            cryptotest += chr(ord('a') + ord(input_str[i]) - ord('A'))
        else:
            if (input_str[i] >= 'a' and input_str[i] <= 'z'):
                cryptotest += input_str[i]

    # 确定密钥长度
    result_len = 1
    result_rate = 99999

    for str_len in range(1, len(cryptotest) + 1):  # 分组长度
        divide_arr = ["" for i in range(0, str_len)]  # 存储分组后的密文
        temp_point = 0
        for i in cryptotest:  # 进行分组
            divide_arr[temp_point] += i
            temp_point = (temp_point + 1) % str_len
        # print(divide_arr)
        divide_rate = [0 for i in range(0, str_len)]  # 存储分组后的密文的重合指数
        for i in range(0, str_len):  # 遍历每一个分组
            divide_arr_count = [0 for i in range(0, 26)]  # 存储第i分组的各个字母的频率
            for now_chr in divide_arr[i]:  # 统计在第i分组中，每个字母出现的次数
                divide_arr_count[ord(now_chr) - ord('a')] += 1
            # print(divide_arr_count)
            now_total_rate = 0
            if (len(divide_arr[i]) == 0) or (len(divide_arr[i]) - 1 == 0):  # 分组后的字符串，长度过小情况下，得不到正常的总概率和，舍弃该情况
                continue
            for j in range(0, 26): # 计算密文中，2个随机字母相同的概率，将26个字母的结果相加得到总概率和
                temp = (divide_arr_count[j] * (divide_arr_count[j] - 1)) / (
                        len(divide_arr[i]) * (len(divide_arr[i]) - 1))
                now_total_rate += temp
            divide_rate[i] = now_total_rate

        now_rate = 0
        for i in range(0, str_len): # 计算每个分组的总概率和与0.065的差值，然后取平均值，得到当前分组长度为str_len的情况下的平均概率
            now_rate += abs(divide_rate[i] - 0.065)
        now_rate /= (str_len)

        if now_rate < result_rate:  # 每次都与当前的频率进行比较，挑选出最优方案
            result_len = str_len
            result_rate = now_rate
    print(f"密钥长度是：{result_len}")

    right_divide_arr = ["" for i in range(0, result_len)]  # 存储分组后的密文
    temp_point = 0
    for i in cryptotest:
        right_divide_arr[temp_point] += i
        temp_point = (temp_point + 1) % result_len

    # 接下来对密钥进行破解
    letter_frequence = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966,
                        0.00153, 0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987,
                        0.06327, 0.09056, 0.02758, 0.00978, 0.0236, 0.0015, 0.01974, 0.00074]

    key_str = ""

    for i in range(0, result_len):  # 遍历每一个分组的密文，破解对应的密钥
        now_letter_count = [0 for i in range(0, 26)]
        for now_chr in right_divide_arr[i]: # 统计在第i分组中，每个字母出现的次数
            now_letter_count[ord(now_chr) - ord('a')] += 1

        may_key = [0 for i in range(0, 26)]

        for step in range(0, 26):  # 遍历可能的key
            now_may_rate = 0
            for j in range(0, 26):  # 遍历26个字母，计算 正确概率*（当前第j字母+移位步数step）的概率，然后对26个字母的结果求和
                point = (j + step) % 26
                temp = letter_frequence[j] * now_letter_count[point]
                now_may_rate += temp
            now_may_rate /= len(right_divide_arr[i])
            may_key[step] = now_may_rate

        result_step = 1
        result_key_rate = 999
        for i in range(0, 26):  # 比较在不同移位步数step的情况下，与0.065的接近程度，得到当前的正确移位数
            if abs(may_key[i] - 0.065) < abs(result_key_rate - 0.065):
                result_step = i
                result_key_rate = may_key[i]
        key_str += chr(result_step + ord('a'))

    print(f"密钥是：{key_str}")
    print(f"解密后的明文是：{VigenereDecrypto(input_str, key_str)}")


if __name__ == '__main__':
    input_number = input("请选择方式：输入1为加密 输入2为解密 输入3为重合指数法破解\n")
    if input_number == "1":
        plaintext = input("请输入明文：")
        input_key = input("请输入密钥：")
        print(f"明文加密后为：{VigenereEncrypto(plaintext, input_key)}")
    elif input_number == "2":
        cryptotest = input("请输入密文：")
        input_key = input("请输入密钥：")
        print(f"密文解密后为：{VigenereDecrypto(cryptotest, input_key)}")
    elif input_number == "3":
        cryptotest = input("请输入密文：")
        VigenereSolveCrypto(cryptotest)
```
